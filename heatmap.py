#
# Warning: Very Hacky Script
#
# This script scrapes PDF files of sensitivity-specificity curves, 
# generated by the compare-vcf.py script, for their AUC values. 
# This is a terrible idea, but was the most feasible approach for
# the sourcing of the required AUC values at the time of writing.
# A saner approach will be developed. 

import os
from pdfminer.pdfinterp import PDFResourceManager, PDFPageInterpreter
from pdfminer.converter import TextConverter
from pdfminer.layout import LAParams
from pdfminer.pdfpage import PDFPage
from cStringIO import StringIO
import matplotlib.pyplot as plt
from matplotlib import cm
from matplotlib.colors import LinearSegmentedColormap
import matplotlib
import pandas as pd
from urllib2 import urlopen
import numpy as np
import re

def pdfToText (path, codec = "utf-8"):
    io          = StringIO()
    pdfManager  = PDFResourceManager()
    converter   = TextConverter(pdfManager, io, codec = codec, laparams = LAParams())
    interpreter = PDFPageInterpreter(pdfManager, converter)
    with file(path, 'rb') as handle:
        for page in PDFPage.get_pages(handle, set(), maxpages = 0, password = "", caching = True, check_extractable = True):
            interpreter.process_page(page)
    text = io.getvalue()
    converter.close()
    io.close()
    return text

if __name__ == "__main__":

    # Imports
    import argparse

    # Parse Arguments
    parser = argparse.ArgumentParser()
    parser.add_argument("-a", "--all", action = "store_true", help = "Generate Heat Map of All VAF Ranges")
    parser.add_argument("-l", "--lfv", action = "store_true", help = "Generate Heat Map of Low Frequency VAF Ranges")
    parser.add_argument("-o", "--output", type = str, help = "Output Prefix")
    argsDict = vars(parser.parse_args())
    allRanges = argsDict["all"]
    lfvRanges = argsDict["lfv"]
    outputdir = argsDict["output"]
    variantRanges = []

    # Input Resolution
    if allRanges is False and lfvRanges is False:
        print("Status: No VAF Range Provided (--all or --lfv), Defaulting to All VAF Ranges")
        variantRanges.append("allranges")
    if outputdir is None:
        outputdir = "output"
    if allRanges:
        variantRanges.append("allranges")
    if lfvRanges:
        variantRanges.append("lfvranges")

    metadata = {

        "datasets" : [
            {
                "name"  : "Set 1",
                "key"   : "set1"
            },
            {
                "name"  : "Set 2",
                "key"   : "set2"
            },
            {
                "name"  : "Set 3",
                "key"   : "set3"
            }
        ],

        "conditions" : [
            {
                "name"  : "BFC",
                "key"   : "bfc"
            },
            {
                "name"  : "Bloocoo",
                "key"   : "bloocoo"
            },
            {
                "name"  : "Lighter",
                "key"   : "lighter"
            },
            {
                "name"  : "No Model",
                "key"   : "nomodel"
            }
        ],
        "subconditions" : [
            {
                "name"  : "No BQSR",
                "key"   : "nobqsr"
            },
            {
                "name"  : "BQSR",
                "key"   : "bqsr"
            }
        ],
        "allranges"  : [("%.2f" % ((i / 2.0) / 10), "%.2f" % (((i + 1) / 2.0 ) / 10)) for i in range(20)],
        "lfvranges"  : [("%.2f" % (i / 100.0), "%.2f" % ((i + 1) / 100.0)) for i in range(15)]

    }

    #
    # Extra Data & Generate Heat Map
    #

    for variantRange in variantRanges:
        vafStr = variantRange[0:3]

        # Structure Matrix & Labels
        xLabels = []
        matrix = {}
        for dataset in metadata["datasets"]:
            for condition in metadata["conditions"]:
                for subcondition in metadata["subconditions"]:
                    xLabel = dataset["name"] + "\n" + condition["name"] + "\n" + subcondition["name"]
                    xLabels.append(xLabel)
                    matrix[dataset["key"] + condition["key"] + subcondition["key"]] = []

        # Fill Matrix With AUC Values from PDFs
        for dataset in metadata["datasets"]:
            for condition in metadata["conditions"]:
                bqsr = matrix[dataset["key"] + condition["key"] + "bqsr"]
                nobqsr = matrix[dataset["key"] + condition["key"] + "nobqsr"]
                for vafrange in metadata[variantRange]:
                    lines = pdfToText("output/%s/%s/senspec-%s-%s-all-variants.pdf" % (dataset["key"], condition["key"], float(vafrange[0]), float(vafrange[1]))).split("\n")
                    for line in lines:
                        if "AUC" in line:
                            # No BQSR Processed First
                            if len(nobqsr) == len(bqsr):
                                n = re.sub(r"^[No\sBQSR]{4,7},\sn\s=\s", "", line[0:-15])
                                auc = float(line[-7:-1])
                                nobqsr.append(auc)
                            else:
                                n = re.sub(r"^[No\sBQSR]{4,7},\sn\s=\s", "", line[0:-15])
                                auc = float(line[-7:-1])
                                bqsr.append(auc)

        #
        # Landscape
        #

        # Coerce to Data Frame
        df = pd.DataFrame(matrix)

        # Colors
        linear_cm = LinearSegmentedColormap.from_list("custom", ["#FFFFFF", "#108070"], N = 256, gamma = 1.0)
        colors = cm.get_cmap(linear_cm)

        # Plot it out
        fig, ax = plt.subplots()
        heatmap = ax.pcolor(df, cmap = colors, alpha = 0.8)

        # Format
        fig = plt.gcf()
        fig.set_size_inches(12, 8)

        # turn off the frame
        ax.set_frame_on(False)

        # put the major ticks at the middle of each cell
        ax.set_yticks(np.arange(df.shape[0]) + 0.5, minor = False)
        ax.set_xticks(np.arange(df.shape[1]) + 0.1, minor = False)

        # want a more natural, table-like display
        ax.invert_yaxis()
        ax.xaxis.tick_top()

        # Set Labels
        ax.set_xticklabels(xLabels, minor = False, fontsize = 5)
        ax.set_yticklabels(["%s - %s" % tup for tup in metadata[variantRange]], minor = False, fontsize = 6)

        # Text Styling
        plt.xticks(ha = "left")
        ax.grid(False)

        # Turn off all the ticks
        ax = plt.gca()

        for t in ax.xaxis.get_major_ticks():
            t.tick1On = False
            t.tick2On = False
        for t in ax.yaxis.get_major_ticks():
            t.tick1On = False
            t.tick2On = False
        fig.savefig("output/%s-%s-heatmap-landscape.pdf" % ("ss-auc", vafStr), bbox_inches = 'tight', transparent = True)
        # plt.show()
        plt.clf()

        #
        # Portrait
        #

        # Coerce to Data Frame
        df = pd.DataFrame(matrix).T

        # Colors
        linear_cm = LinearSegmentedColormap.from_list("custom", ["#FFFFFF", "#108070"], N = 256, gamma = 1.0)
        colors = cm.get_cmap(linear_cm)

        # Plot it out
        fig, ax = plt.subplots()
        heatmap = ax.pcolor(df, cmap = colors, alpha=0.8)

        # Format
        fig = plt.gcf()
        fig.set_size_inches(8, 11)

        # turn off the frame
        ax.set_frame_on(False)

        # put the major ticks at the middle of each cell
        ax.set_yticks(np.arange(df.shape[0]) + .5, minor = False)
        ax.set_xticks(np.arange(df.shape[1]) + .5, minor = False)

        # want a more natural, table-like display
        ax.invert_yaxis()
        ax.xaxis.tick_top()

        # Set Labels
        ax.set_yticklabels(xLabels, minor = False, fontsize = 6)
        ax.set_xticklabels(["%s - %s" % tup for tup in metadata[variantRange]], minor = False, fontsize = 6)

        # Text Styling
        plt.xticks(rotation = 45)
        ax.grid(False)

        # Turn off all the ticks
        ax = plt.gca()

        for t in ax.xaxis.get_major_ticks():
            t.tick1On = False
            t.tick2On = False
        for t in ax.yaxis.get_major_ticks():
            t.tick1On = False
            t.tick2On = False
        fig.savefig("output/%s-%s-heatmap-portrait.pdf" % ("ss-auc", vafStr), bbox_inches = 'tight', transparent = True)
        # plt.show()
        plt.clf()
else:
    pass